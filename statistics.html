<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>통계 - 화도웹</title>
    <link rel="stylesheet" href="style.css">
    <style>
        .mode-selector { margin-bottom: 20px; text-align: center; }
        .mode-selector button { width: 150px; }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            max-width: 500px;
            width: 90%;
            max-height: 90%;
            overflow-y: auto;
            text-align: left;
            position: relative;
        }
        .modal-content h2 {
            text-align: center;
            margin-top: 0;
            margin-bottom: 20px;
            color: #333;
        }
        .modal-content p {
            margin-bottom: 8px;
            line-height: 1.5;
            color: #555;
        }
        .modal-content p strong { color: #1a1a1a; }
        .modal-content button {
            display: block;
            margin: 20px auto 0 auto;
            padding: 10px 20px;
            background-color: white;
            color: #333;
            border: 1px solid #ccc;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .modal-content button:hover { background-color: #e9e9e9; }
        .modal-content .blank-line { height: 15px; border-bottom: 1px solid #eee; margin-bottom: 15px; }

        /* Fix for hidden class */
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <a href="index.html" class="header-link"><h1>화도웹</h1></a>

    <div class="container">
        <div class="mode-selector">
            <button id="refine-stats-btn">강화 통계</button>
            <button id="amplify-stats-btn">증폭 통계</button>
        </div>
        <div id="ranking-table-container">
            <p>랭킹 데이터를 불러오는 중...</p>
        </div>
    </div>

    <!-- User Details Modal -->
    <div id="user-details-modal-overlay" class="modal-overlay hidden">
        <div id="user-details-modal-content" class="modal-content">
            <h2 id="modal-title"></h2>
            <p id="modal-level-info"></p>
            <p id="modal-max-stat"></p>
            <p id="modal-costs"></p>
            <p id="modal-destructions"></p>
            <div class="blank-line"></div>
            <p id="modal-achievements-12-10"></p>
            <p id="modal-achievements-13-11"></p>
            <p id="modal-achievements-14-12"></p>
            <p id="modal-achievements-15-13"></p>
            <p id="modal-achievements-16-14"></p>
            <p id="modal-achievements-17-15"></p>
            <div class="blank-line"></div>
            <p id="modal-max-attempt"></p>
            <p id="modal-min-attempt"></p>
            <div class="blank-line"></div>
            <p id="modal-last-activity"></p>
            <button id="modal-close-btn">닫기</button>
        </div>
    </div>

    <script>
        let state = {
            refine: { users: [], levelData: [] },
            amplify: { users: [], levelData: [] },
            currentMode: 'refine',
            currentSort: { key: 'totalXp', direction: 'desc' }
        };

        const calculateRefineXp = (level) => level < 12 ? 0 : Math.pow(3, level - 12);
        const calculateAmplifyXp = (level) => { if (level < 10) return 0; if (level === 10) return 1; if (level === 11) return 2; if (level === 12) return 5; return 5 * Math.pow(3, level - 12); };

        function getDetailedLevelFromXp(xp, levelData) {
            let currentLevel = 1, nextLevelXp = 0, perk = '혜택 없음', nextPerk = '최고 레벨';

            if (levelData.length > 0) {
                perk = levelData[0][2] || '혜택 없음';
                nextLevelXp = parseInt(levelData[0][1]) || 1;
                if (levelData.length > 1) nextPerk = levelData[1][2] || '혜택 없음';

                for (let i = 0; i < levelData.length; i++) {
                    const level = parseInt(levelData[i][0]);
                    const requiredXp = parseInt(levelData[i][1]);

                    if (xp >= requiredXp) {
                        currentLevel = level;
                        perk = levelData[i][2] || '혜택 없음';

                        if (i + 1 < levelData.length) {
                            nextLevelXp = parseInt(levelData[i+1][1]);
                            nextPerk = levelData[i+1][2] || '혜택 없음';
                        } else {
                            nextLevelXp = requiredXp;
                            nextPerk = '최고 레벨';
                        }
                    } else {
                        nextLevelXp = requiredXp;
                        nextPerk = levelData[i][2] || '혜택 없음';
                        break;
                    }
                }
            }
            return { currentLevel, nextLevelXp, perk, nextPerk };
        }

        function renderTable() {
            const container = document.getElementById('ranking-table-container');
            const mode = state.currentMode;
            const usersToRender = state[mode].users;
            container.innerHTML = '';

            if (usersToRender.length === 0) {
                container.innerHTML = '<p>데이터가 없습니다.</p>';
                return;
            }

            const table = document.createElement('table');
            const isRefine = mode === 'refine';
            const headers = [
                { key: 'nickname', text: '닉네임', type: 'string' },
                { key: 'level', text: '레벨', type: 'number' },
                { key: 'maxStat', text: isRefine ? '최고 강화 단계' : '최고 증폭 단계', type: 'number' },
                { key: 'totalGold', text: '누적 소모 골드', type: 'number' },
                ...(isRefine ? [] : [{ key: 'totalCrystals', text: '누적 모순 갯수', type: 'number' }]),
                { key: 'destructionCount', text: '누적 파괴 횟수', type: 'number' },
                { key: 'totalXp', text: '누적 경험치', type: 'number' }
            ];

            let headerHtml = '<tr>';
            headers.forEach(h => { headerHtml += `<th data-sort-key="${h.key}" data-sort-type="${h.type}">${h.text}</th>`; });
            headerHtml += '</tr>';
            table.innerHTML = `<thead>${headerHtml}</thead><tbody></tbody>`;
            const tbody = table.querySelector('tbody');

            usersToRender.forEach(user => {
                const row = tbody.insertRow();
                row.insertCell().textContent = user.nickname;
                row.insertCell().textContent = user.level;
                row.insertCell().textContent = `+${user.maxStat}`;
                row.insertCell().textContent = `${(user.totalGold / 100000000).toFixed(2)}억`;
                if (!isRefine) row.insertCell().textContent = user.totalCrystals.toLocaleString();
                row.insertCell().textContent = user.destructionCount;
                const xpCell = row.insertCell();
                xpCell.textContent = user.totalXp.toLocaleString();
                xpCell.style.textAlign = 'left';

                row.style.cursor = 'pointer';
                row.addEventListener('click', () => {
                    console.log('Row clicked for user:', user.nickname);
                    showUserDetailsModal(user);
                });
            });

            container.appendChild(table);

            table.querySelectorAll('th').forEach(header => {
                header.addEventListener('click', () => {
                    const sortKey = header.dataset.sortKey;
                    const sortType = header.dataset.sortType;
                    sortTable(sortKey, sortType);
                });
            });
        }

        function sortTable(columnKey, type) {
            if (state.currentSort.key === columnKey) {
                state.currentSort.direction = (state.currentSort.direction === 'asc') ? 'desc' : 'asc';
            } else {
                state.currentSort.key = columnKey;
                state.currentSort.direction = (type === 'string') ? 'asc' : 'desc';
            }

            state[state.currentMode].users.sort((a, b) => {
                let comparison = 0;
                const valA = a[columnKey] || 0;
                const valB = b[columnKey] || 0;
                if (type === 'string') { comparison = valA.localeCompare(valB); }
                else { comparison = valA - valB; }
                return (state.currentSort.direction === 'asc') ? comparison : -comparison;
            });

            renderTable();
        }

        function processData(mode, rankingData, levelData) {
            const usersMap = new Map();
            const calculateXp = mode === 'refine' ? calculateRefineXp : calculateAmplifyXp;

            rankingData.forEach(row => {
                const nickname = row[0];
                const statLevel = parseInt(row[1]);
                const goldSpent = parseInt(row[2]);
                const crystalsSpent = mode === 'amplify' ? parseInt(row[3] || 0) : 0;
                const timestampStr = row[mode === 'refine' ? 3 : 4];
                let timestamp = null;
                console.log('Processing timestampStr:', timestampStr);
                if (timestampStr) {
                    const parts = timestampStr.match(/(\d{4})\.\s*(\d{1,2})\.\s*(\d{1,2})\.\s*(오전|오후)\s*(\d{1,2}):(\d{1,2}):(\d{1,2})/);
                    console.log('Regex parts:', parts);
                    if (parts) {
                        let year = parseInt(parts[1]);
                        let month = parseInt(parts[2]) - 1; // Month is 0-indexed
                        let day = parseInt(parts[3]);
                        let hour = parseInt(parts[5]);
                        let minute = parseInt(parts[6]);
                        let second = parseInt(parts[7]);
                        const ampm = parts[4];

                        if (ampm === '오후' && hour < 12) { hour += 12; }
                        else if (ampm === '오전' && hour === 12) { hour = 0; }
                        timestamp = new Date(year, month, day, hour, minute, second);
                        console.log('Constructed Date object:', timestamp, 'isNaN:', isNaN(timestamp.getTime()));
                    }
                }

                if (!usersMap.has(nickname)) {
                    usersMap.set(nickname, {
                        maxStat: 0, totalGold: 0, totalCrystals: 0, destructionCount: 0, totalXp: 0,
                        achievements: {},
                        lastActivity: null,
                        allAttempts: []
                    });
                }

                const userData = usersMap.get(nickname);
                userData.maxStat = Math.max(userData.maxStat, statLevel);
                userData.totalGold += goldSpent;
                if (mode === 'amplify') userData.totalCrystals += crystalsSpent;
                userData.destructionCount++;
                userData.totalXp += calculateXp(statLevel);
                if (timestamp && (!userData.lastActivity || timestamp > userData.lastActivity)) {
                    userData.lastActivity = timestamp;
                }
                userData.allAttempts.push({ level: statLevel, gold: goldSpent, timestamp: timestamp });
            });

            return Array.from(usersMap.entries()).map(([nickname, data]) => {
                const achievements = {};
                const achievementLevels = mode === 'refine' ? [12, 13, 14, 15, 16, 17] : [10, 11, 12, 13, 14, 15];
                achievementLevels.forEach(targetLevel => {
                    const key = mode === 'refine' ? `plus${targetLevel}` : `plus${targetLevel}`;
                    achievements[key] = data.allAttempts.filter(attempt => attempt.level >= targetLevel).length;
                });

                let maxAttemptGold = 0;
                let maxAttemptLevel = 0;
                let minAttemptGold = Infinity;
                let minAttemptLevel = 0;

                data.allAttempts.forEach(attempt => {
                    if (attempt.gold > maxAttemptGold) {
                        maxAttemptGold = attempt.gold;
                        maxAttemptLevel = attempt.level;
                    }
                    if (attempt.gold < minAttemptGold) {
                        minAttemptGold = attempt.gold;
                        minAttemptLevel = attempt.level;
                    }
                });

                return {
                    nickname: nickname,
                    level: getDetailedLevelFromXp(data.totalXp, levelData).currentLevel,
                    maxStat: data.maxStat,
                    totalGold: data.totalGold,
                    totalCrystals: data.totalCrystals,
                    destructionCount: data.destructionCount,
                    totalXp: data.totalXp,
                    achievements: achievements,
                    lastActivity: data.lastActivity,
                    maxAttemptGold: maxAttemptGold,
                    maxAttemptLevel: maxAttemptLevel,
                    minAttemptGold: minAttemptGold === Infinity ? 0 : minAttemptGold,
                    minAttemptLevel: minAttemptLevel
                };
            });
        }

        // Helper to format date to Korean locale and KST
        function formatKoreanDateTime(date) {
            if (!date || isNaN(date.getTime())) return '알 수 없음';

            const options = {
                year: 'numeric',
                month: 'numeric',
                day: 'numeric',
                hour: 'numeric',
                minute: 'numeric',
                second: 'numeric',
                hour12: false, // Use 24-hour format first
                timeZone: 'Asia/Seoul'
            };

            let formatted = new Intl.DateTimeFormat('ko-KR', options).format(date);

            // Manual conversion to 오전/오후
            const parts = formatted.split(' ');
            const datePart = parts.slice(0, 3).join('. ') + '.'; // YYYY. MM. DD.
            const timePart = parts[3]; // HH:MM:SS
            const hour = parseInt(timePart.split(':')[0]);
            const ampm = hour < 12 ? '오전' : '오후';
            const displayHour = hour % 12 === 0 ? 12 : hour % 12; // Convert 0 to 12 for AM/PM

            const newTimePart = `${ampm} ${displayHour}:${timePart.split(':')[1]}:${timePart.split(':')[2]}`;
            
            return `${datePart} ${newTimePart}`;
        }

        // Modal Functions
        function showUserDetailsModal(user) {
            console.log('showUserDetailsModal called for user:', user.nickname);
            const modalOverlay = document.getElementById('user-details-modal-overlay');
            const modalTitle = document.getElementById('modal-title');
            const modalLevelInfo = document.getElementById('modal-level-info');
            const modalMaxStat = document.getElementById('modal-max-stat');
            const modalCosts = document.getElementById('modal-costs');
            const modalDestructions = document.getElementById('modal-destructions');
            const modalAchievements12_10 = document.getElementById('modal-achievements-12-10');
            const modalAchievements13_11 = document.getElementById('modal-achievements-13-11');
            const modalAchievements14_12 = document.getElementById('modal-achievements-14-12');
            const modalAchievements15_13 = document.getElementById('modal-achievements-15-13');
            const modalAchievements16_14 = document.getElementById('modal-achievements-16-14');
            const modalAchievements17_15 = document.getElementById('modal-achievements-17-15');
            const modalMaxAttempt = document.getElementById('modal-max-attempt');
            const modalMinAttempt = document.getElementById('modal-min-attempt');
            const modalLastActivity = document.getElementById('modal-last-activity');

            const mode = state.currentMode;
            const isRefine = mode === 'refine';
            const statType = isRefine ? '강화' : '증폭';
            const achievementPrefix = isRefine ? '+' : '+';

            modalTitle.textContent = `${user.nickname} ${statType} 상세 통계`;
            modalLevelInfo.innerHTML = `Lv.${user.level} (경험치 : ${user.totalXp.toLocaleString()}/${getDetailedLevelFromXp(user.totalXp, state[mode].levelData).nextLevelXp.toLocaleString()})`;
            modalMaxStat.textContent = `최고 ${statType} 단계 : +${user.maxStat}`;
            
            let costsText = `누적 소모 골드 : ${user.totalGold.toLocaleString()}`; 
            if (!isRefine) {
                costsText += `, 누적 소모 모순의 결정체 : ${user.totalCrystals.toLocaleString()}`; 
            }
            modalCosts.textContent = costsText;
            modalDestructions.textContent = `누적 파괴 횟수 : ${user.destructionCount}`;

            const displayLevels = [
                { refine: 12, amplify: 10 },
                { refine: 13, amplify: 11 },
                { refine: 14, amplify: 12 },
                { refine: 15, amplify: 13 },
                { refine: 16, amplify: 14 },
                { refine: 17, amplify: 15 }
            ];

            displayLevels.forEach((levels, index) => {
                const currentLevel = isRefine ? levels.refine : levels.amplify;
                const achievementCount = user.achievements[`plus${currentLevel}`] || 0;
                const elementId = `modal-achievements-${levels.refine}-${levels.amplify}`;
                const element = document.getElementById(elementId);
                if (element) {
                    element.textContent = `${achievementPrefix}${currentLevel} 도달 횟수 : ${achievementCount}`;
                }
            });

            modalMaxAttempt.textContent = `가장 많은 비용을 사용한 시도 : ${user.maxAttemptGold.toLocaleString()}골드 / +${user.maxAttemptLevel}${statType}`;
            modalMinAttempt.textContent = `가장 적은 비용을 사용한 시도 : ${user.minAttemptGold.toLocaleString()}골드 / +${user.minAttemptLevel}${statType}`;

            modalLastActivity.textContent = `마지막 활동일 : ${formatKoreanDateTime(user.lastActivity)}`;

            modalOverlay.classList.remove('hidden');
            console.log('Modal should be visible.');
        }

        function closeUserDetailsModal() {
            console.log('closeUserDetailsModal called.');
            document.getElementById('user-details-modal-overlay').classList.add('hidden');
        }

        async function initialize() {
            const container = document.getElementById('ranking-table-container');
            try {
                const [refineRankingRes, refineLevelRes, ampRankingRes, ampLevelRes] = await Promise.all([
                    fetch('/.netlify/functions/sheets?sheetName=강화랭킹'),
                    fetch('/.netlify/functions/sheets?sheetName=레벨'),
                    fetch('/.netlify/functions/sheets?sheetName=증폭랭킹'),
                    fetch('/.netlify/functions/sheets?sheetName=레벨2')
                ]);

                const refineRankingData = (await refineRankingRes.json()).data;
                state.refine.levelData = (await refineLevelRes.json()).data;
                state.refine.users = processData('refine', refineRankingData, state.refine.levelData);

                const ampRankingData = (await ampRankingRes.json()).data;
                state.amplify.levelData = (await ampLevelRes.json()).data;
                state.amplify.users = processData('amplify', ampRankingData, state.amplify.levelData);

                state.refine.users.sort((a, b) => b.totalXp - a.totalXp); 
                state.amplify.users.sort((a, b) => b.totalXp - a.totalXp); 

                document.getElementById('refine-stats-btn').addEventListener('click', () => { state.currentMode = 'refine'; renderTable(); });
                document.getElementById('amplify-stats-btn').addEventListener('click', () => { state.currentMode = 'amplify'; renderTable(); });
                document.getElementById('modal-close-btn').addEventListener('click', closeUserDetailsModal);
                document.getElementById('user-details-modal-overlay').addEventListener('click', (e) => {
                    if (e.target.id === 'user-details-modal-overlay') { closeUserDetailsModal(); }
                });
                
                renderTable();

            } catch (error) {
                console.error('Error fetching or processing ranking data:', error);
                container.innerHTML = '<p>랭킹 데이터를 불러오는 데 실패했습니다. 잠시 후 다시 시도해주세요.</p>';
            }
        }

        document.addEventListener('DOMContentLoaded', initialize);
    </script>
</body>
</html>