<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>통계 - 화도웹</title>
    <link rel="stylesheet" href="style.css">
    <style>
        .mode-selector { margin-bottom: 20px; text-align: center; }
        .mode-selector button { width: 150px; }
    </style>
</head>
<body>
    <a href="index.html" class="header-link"><h1>화도웹</h1></a>

    <div class="container">
        <div class="mode-selector">
            <button id="refine-stats-btn">강화 통계</button>
            <button id="amplify-stats-btn">증폭 통계</button>
        </div>
        <div id="ranking-table-container">
            <p>랭킹 데이터를 불러오는 중...</p>
        </div>
    </div>

    <script>
        let state = {
            refine: { users: [], levelData: [] },
            amplify: { users: [], levelData: [] },
            currentMode: 'refine',
            currentSort: { key: 'level', direction: 'desc' }
        };

        const calculateRefineXp = (level) => level < 12 ? 0 : Math.pow(3, level - 12);
        const calculateAmplifyXp = (level) => { if (level < 10) return 0; if (level === 10) return 1; if (level === 11) return 2; if (level === 12) return 5; return 5 * Math.pow(3, level - 12); };

        function getLevelFromXp(xp, levelData) {
            let currentLevel = 1;
            for (const row of levelData) {
                const level = parseInt(row[0]);
                const requiredXp = parseInt(row[1]);
                if (xp >= requiredXp) { currentLevel = level; } else { break; }
            }
            return currentLevel;
        }

        function renderTable() {
            const container = document.getElementById('ranking-table-container');
            const mode = state.currentMode;
            const usersToRender = state[mode].users;
            container.innerHTML = '';

            if (usersToRender.length === 0) {
                container.innerHTML = '<p>데이터가 없습니다.</p>';
                return;
            }

            const table = document.createElement('table');
            const isRefine = mode === 'refine';
            const headers = [
                { key: 'nickname', text: '닉네임', type: 'string' },
                { key: 'level', text: '레벨', type: 'number' },
                { key: 'maxStat', text: isRefine ? '최고 강화 단계' : '최고 증폭 단계', type: 'number' },
                { key: 'totalGold', text: '누적 소모 골드', type: 'number' },
                ...(isRefine ? [] : [{ key: 'totalCrystals', text: '누적 모순 갯수', type: 'number' }]),
                { key: 'destructionCount', text: '누적 파괴 횟수', type: 'number' },
                { key: 'totalXp', text: '누적 경험치', type: 'number' }
            ];

            let headerHtml = '<tr>';
            headers.forEach(h => { headerHtml += `<th data-sort-key="${h.key}" data-sort-type="${h.type}">${h.text}</th>`; });
            headerHtml += '</tr>';
            table.innerHTML = `<thead>${headerHtml}</thead><tbody></tbody>`;
            const tbody = table.querySelector('tbody');

            usersToRender.forEach(user => {
                const row = tbody.insertRow();
                row.insertCell().textContent = user.nickname;
                row.insertCell().textContent = user.level;
                row.insertCell().textContent = `+${user.maxStat}`;
                row.insertCell().textContent = `${(user.totalGold / 100000000).toFixed(2)}억`;
                if (!isRefine) row.insertCell().textContent = user.totalCrystals.toLocaleString();
                row.insertCell().textContent = user.destructionCount;
                row.insertCell().textContent = user.totalXp.toLocaleString();
            });

            container.appendChild(table);

            table.querySelectorAll('th').forEach(header => {
                header.addEventListener('click', () => {
                    const sortKey = header.dataset.sortKey;
                    const sortType = header.dataset.sortType;
                    sortTable(sortKey, sortType);
                });
            });
        }

        function sortTable(columnKey, type) {
            if (state.currentSort.key === columnKey) {
                state.currentSort.direction = (state.currentSort.direction === 'asc') ? 'desc' : 'asc';
            } else {
                state.currentSort.key = columnKey;
                state.currentSort.direction = (type === 'string') ? 'asc' : 'desc';
            }

            state[state.currentMode].users.sort((a, b) => {
                let comparison = 0;
                if (type === 'string') { comparison = a[columnKey].localeCompare(b[columnKey]); }
                else { comparison = a[columnKey] - b[columnKey]; }
                return (state.currentSort.direction === 'asc') ? comparison : -comparison;
            });

            renderTable();
        }

        function processData(mode, rankingData, levelData) {
            const usersMap = new Map();
            const calculateXp = mode === 'refine' ? calculateRefineXp : calculateAmplifyXp;

            rankingData.forEach(row => {
                const nickname = row[0];
                const statLevel = parseInt(row[1]);
                const goldSpent = parseInt(row[2]);
                const crystalsSpent = mode === 'amplify' ? parseInt(row[3] || 0) : 0;

                if (!usersMap.has(nickname)) {
                    usersMap.set(nickname, { maxStat: 0, totalGold: 0, totalCrystals: 0, destructionCount: 0, totalXp: 0 });
                }

                const userData = usersMap.get(nickname);
                userData.maxStat = Math.max(userData.maxStat, statLevel);
                userData.totalGold += goldSpent;
                if (mode === 'amplify') userData.totalCrystals += crystalsSpent;
                userData.destructionCount++;
                userData.totalXp += calculateXp(statLevel);
            });

            return Array.from(usersMap.entries()).map(([nickname, data]) => ({
                nickname: nickname,
                level: getLevelFromXp(data.totalXp, levelData),
                maxStat: data.maxStat,
                totalGold: data.totalGold,
                totalCrystals: data.totalCrystals,
                destructionCount: data.destructionCount,
                totalXp: data.totalXp
            }));
        }

        async function initialize() {
            const container = document.getElementById('ranking-table-container');
            try {
                const [refineRankingRes, refineLevelRes, ampRankingRes, ampLevelRes] = await Promise.all([
                    fetch('/.netlify/functions/sheets?sheetName=강화랭킹'),
                    fetch('/.netlify/functions/sheets?sheetName=레벨'),
                    fetch('/.netlify/functions/sheets?sheetName=증폭랭킹'),
                    fetch('/.netlify/functions/sheets?sheetName=레벨2')
                ]);

                const refineRankingData = (await refineRankingRes.json()).data;
                state.refine.levelData = (await refineLevelRes.json()).data;
                state.refine.users = processData('refine', refineRankingData, state.refine.levelData);

                const ampRankingData = (await ampRankingRes.json()).data;
                state.amplify.levelData = (await ampLevelRes.json()).data;
                state.amplify.users = processData('amplify', ampRankingData, state.amplify.levelData);

                document.getElementById('refine-stats-btn').addEventListener('click', () => { state.currentMode = 'refine'; renderTable(); });
                document.getElementById('amplify-stats-btn').addEventListener('click', () => { state.currentMode = 'amplify'; renderTable(); });
                
                // Initial sort and render
                sortTable(state.currentSort.key, 'number');

            } catch (error) {
                console.error('Error fetching or processing ranking data:', error);
                container.innerHTML = '<p>랭킹 데이터를 불러오는 데 실패했습니다. 잠시 후 다시 시도해주세요.</p>';
            }
        }

        document.addEventListener('DOMContentLoaded', initialize);
    </script>
</body>
</html>
