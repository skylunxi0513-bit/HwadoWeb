<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>화도웹 - 카드 가격</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <a href="index.html" class="header-link">
        <h1>화도웹</h1>
    </a>

    <div class="enchant-buttons-container">
        <button id="dealer-btn">딜러</button>
        <button id="buffer-btn">버퍼</button>
    </div>

    <div id="enchant-main-container" class="hidden">
        <div id="left-container" class="enchant-sub-container">
            <div class="enchant-box"></div>
            <div class="enchant-box"></div>
            <div class="enchant-box"></div>
            <div class="enchant-box"></div>
            <div class="enchant-box"></div>
            <div class="enchant-box transparent"></div>
            <div class="enchant-box transparent"></div>
            <div class="enchant-box transparent"></div>
        </div>
        <div id="right-container" class="enchant-sub-container">
            <div class="enchant-box"></div>
            <div class="enchant-box transparent"></div>
            <div class="enchant-box"></div>
            <div class="enchant-box"></div>
            <div class="enchant-box"></div>
            <div class="enchant-box"></div>
            <div class="enchant-box"></div>
            <div class="enchant-box"></div>
        </div>
    </div>

    <script>
        const dealerBtn = document.getElementById('dealer-btn');
        const bufferBtn = document.getElementById('buffer-btn');
        const mainContainer = document.getElementById('enchant-main-container');
        const leftBoxes = Array.from(document.querySelectorAll('#left-container .enchant-box:not(.transparent)'));
        const rightBoxes = Array.from(document.querySelectorAll('#right-container .enchant-box:not(.transparent)'));
        const allBoxes = [...leftBoxes, ...rightBoxes];

        // --- Reusable API Call Functions ---

        // Fetches filtered data from the Google Sheet
        async function fetchSheetData(type) {
            const response = await fetch(`/.netlify/functions/sheets?sheetName=카드가격&filterColumn=3&filterValue=${encodeURIComponent(type)}`);
            if (!response.ok) {
                throw new Error(`Sheets API Error: ${response.status}`);
            }
            const result = await response.json();
            if (result.error) {
                throw new Error(result.error);
            }
            return result.data; // Assuming result.data is the array of rows
        }

        // Fetches the lowest price for a single item
        async function fetchPrice(itemName) {
            try {
                const response = await fetch(`/.netlify/functions/auction?itemName=${encodeURIComponent(itemName)}`);
                if (!response.ok) return Infinity;
                const data = await response.json();
                return (data.rows && data.rows.length > 0) ? data.rows[0].unitPrice : Infinity;
            } catch (error) {
                console.error(`Price fetch failed for ${itemName}:`, error);
                return Infinity;
            }
        }

        // --- Main Orchestration Function ---

        const fetchDataAndRender = async (type) => {
            mainContainer.classList.remove('hidden');
            allBoxes.forEach(box => { box.innerHTML = '로딩 중...'; });

            try {
                // 1. Fetch initial card data from the sheet
                const sheetRows = await fetchSheetData(type);

                // 2. Fetch prices for all cards in parallel
                const pricePromises = sheetRows.map(row => fetchPrice(row[3]).then(price => ({
                    boxIndex: row[0],
                    priority: parseInt(row[1], 10),
                    name: row[3],
                    image: row[4],
                    price: price
                })));
                
                const itemsWithPrices = await Promise.all(pricePromises);

                // 3. Group items by their designated box
                const groupedByBox = itemsWithPrices.reduce((acc, item) => {
                    if (!acc[item.boxIndex]) acc[item.boxIndex] = [];
                    acc[item.boxIndex].push(item);
                    return acc;
                }, {});

                // 4. Process each group: sort by priority and handle tie-breaks
                for (const boxIndex in groupedByBox) {
                    const items = groupedByBox[boxIndex];
                    const processedItems = [];
                    const groupedByPriority = items.reduce((acc, item) => {
                        if (!acc[item.priority]) acc[item.priority] = [];
                        acc[item.priority].push(item);
                        return acc;
                    }, {});

                    const sortedPriorities = Object.keys(groupedByPriority).sort((a, b) => a - b);

                    for (const priority of sortedPriorities) {
                        const priorityGroup = groupedByPriority[priority];
                        if (priorityGroup.length > 0) {
                            const cheapestItem = priorityGroup.reduce((cheapest, current) => 
                                current.price < cheapest.price ? current : cheapest
                            );
                            processedItems.push(cheapestItem);
                        }
                    }
                    groupedByBox[boxIndex] = processedItems;
                }

                // 5. Render the final data
                allBoxes.forEach(box => { box.innerHTML = ''; });

                const boxMapping = {
                    '1': leftBoxes[0], '2': leftBoxes[1], '3': leftBoxes[2], '4': leftBoxes[3], '5': leftBoxes[4],
                    '6': rightBoxes[0], '7': rightBoxes[1], '8': rightBoxes[2], '9': rightBoxes[3], '10': rightBoxes[4], '11': rightBoxes[5], '12': rightBoxes[6]
                };

                for (const boxIndex in groupedByBox) {
                    const targetBox = boxMapping[boxIndex];
                    if (targetBox) {
                        const items = groupedByBox[boxIndex];
                        items.forEach(item => {
                            const itemDiv = document.createElement('div');
                            itemDiv.className = 'card-item';
                            const priceString = item.price === Infinity ? '매물 없음' : `${item.price.toLocaleString()} G`;
                            
                            itemDiv.innerHTML = `
                                <img src="images/${item.image}" alt="${item.name}">
                                <span class="card-name">${item.name}</span>
                                <span class="card-price">${priceString}</span>
                            `;
                            targetBox.appendChild(itemDiv);
                        });
                    }
                }

            } catch (error) {
                console.error('Failed to fetch and render card data:', error);
                allBoxes.forEach(box => { box.innerHTML = '오류 발생'; });
            }
        };

        dealerBtn.addEventListener('click', () => fetchDataAndRender('딜러'));
        bufferBtn.addEventListener('click', () => fetchDataAndRender('버퍼'));
    </script>
</body>
</html>